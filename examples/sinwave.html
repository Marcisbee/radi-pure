<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Radi sinwave</title>
  <style>
    body {
      font-family: Arial;
    }
    * {
      box-sizing: border-box;
    }
    .animated-sin-wave {
      position: relative;
      height: 150px;
      width: 100%;
      overflow: hidden;
    }

    .animated-sin-wave > .bar {
      position: absolute;
      height: 100%;
      border-radius: 50%;
      max-width: 10px;
      transform: scale(0.8,.5) translateY(0%) rotate(0deg)
    }

    .animated-sin-wave-description {
      width: 100%;
      text-align: center;
      font-size: 0.8em;
      color: #747678;
      padding: 2em;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <script src="https://unpkg.com/@babel/standalone@7.0.0/babel.min.js"></script>
  <script src="../src/index.js"></script>
  <script>
    const rand = Math.random

    function buildData(count, start) {
      start = (start) ? start : 0;
      const adjectives = [
        "pretty",
        "large",
        "big",
        "small",
        "tall",
        "short",
        "long",
        "handsome",
        "plain",
        "quaint",
        "clean",
        "elegant",
        "easy",
        "angry",
        "crazy",
        "helpful",
        "mushy",
        "odd",
        "unsightly",
        "adorable",
        "important",
        "inexpensive",
        "cheap",
        "expensive",
        "fancy",
      ]

      const colours = [
        "red",
        "yellow",
        "blue",
        "green",
        "pink",
        "brown",
        "purple",
        "brown",
        "white",
        "black",
        "orange",
      ]

      const nouns = [
        "table",
        "chair",
        "house",
        "bbq",
        "desk",
        "car",
        "pony",
        "cookie",
        "sandwich",
        "burger",
        "pizza",
        "mouse",
        "keyboard",
      ]

      var i = start + 1;
      return new Array(count).fill(0).map(_ => ({ id: i++, value: `${adjectives[
        rand() * 1000 % adjectives.length >> 0]} ${colours[
        rand() * 1000 % colours.length >> 0]} ${nouns[
        rand() * 1000 % nouns.length >> 0]}`
      }))
    }

  </script>
  <script type="text/babel">
    /* @jsx h */


    function devTools(_radi) {
      const { h } = _radi;

      const dev = new _radi.Store({
        stores: [],
        actions: [],
        active: 0,
      })
      const storeHolder = {};

      function stripFunctions(target) {
        var out = {}

        for (var i in target) {
          out[i] = typeof target[i] === 'function'
            ? null
            : (typeof target[i] === 'object' && !Array.isArray(target[i])) ? stripFunctions(target[i]) : target[i];
        }

        return out
      }

      const setActive = ({actions, stores, active}, newActive) => {
        let current = actions.reduce((acc, nn, ii) => nn.index === newActive ? ii + 1 : acc, 0);
        let inBetweenActions = actions.slice(current, active);
        let originals = actions
          .slice(0, current)
          .reduce(
            (acc, act) => (acc[act.store] = (acc[act.store] || []).concat(act.payload),acc),
            {}
          );

        for (var i = 0; i < stores.length; i++) {
          if (typeof originals[stores[i]] !== 'undefined') {
            storeHolder[stores[i]].update(
              Object.assign(
                stripFunctions(storeHolder[stores[i]].getInitial()),
                ...originals[stores[i]].map(stripFunctions)
              ), true
            );
          } else {
            for (var n = 0; n < inBetweenActions.length; n++) {
              if (stores[i] === inBetweenActions[n].store) {
                storeHolder[stores[i]].update(
                  Object.assign(
                    stripFunctions(storeHolder[stores[i]].getInitial()),
                    stripFunctions(inBetweenActions[n].payload)
                  ), true
                );
                break;
              }
            }
          }
        }

        return { active: newActive };
      }
      const next = ({actions, active}) => {
        const go = actions.reduce((acc, nn, ii) => nn.index === active ? ii : acc, 0) + 1;
        if (go < actions.length) {
          dev.dispatch(setActive, actions[go].index);
        }
      }
      const previous = ({actions, active}) => {
        const go = actions.reduce((acc, nn, ii) => nn.index === active ? ii : acc, 0) - 1;
        if (go >= 0) {
          dev.dispatch(setActive, actions[go].index);
        }
      }
      const addStore = ({stores}, newStore) => ({stores: stores.concat(newStore)})
      const addAction = ({actions, active}, newAction) => {
        const lastIndex = actions.length && actions[actions.length - 1].index || 0;
        let actionSet = (lastIndex !== active && actions.slice(0, actions.reduce((acc, nn, ii) => nn.index === active ? ii + 1 : acc, 0))) || actions;
        newAction.index = lastIndex + 1;
        return {
          actions: actionSet.concat(newAction),
          active: lastIndex + 1,
        };
      }

      let current = new Date().getTime()
      const time = () => {
        const tempTime = current;
        current = new Date().getTime();
        return () => current - tempTime;
      }

      function Store(state, name) {
        const storeName = name || 'unnamed-' + (dev.get().stores.length + 1);
        dev.dispatch(addStore, storeName);
        let a = _radi.Store(state);
        const superUpdate = a.update;
        const superDispatch = a.dispatch;
        storeHolder[storeName] = {
          getInitial: a.getInitial,
          update: superUpdate,
        };

        a.update = function(payload, noSubs, fn, newTime) {
          if (fn) {
            dev.dispatch(addAction, {
              name: fn.name,
              payload: stripFunctions(payload),
              time: (newTime() / 1000).toFixed(2),
              store: storeName,
            })
          }
          // console.log(payload, fn.name, newTime())
          return superUpdate(payload, noSubs)
        }

        a.dispatch = function(fn, ...args) {
          const payload = fn(a.get(), ...args);
          // console.log(fn.name)
          // console.log('dispatch', {
          //   action: fn.name,
          //   args: args,
          //   payload,
          // });
          // console.log('dispatch', fn.name, payload);
          return this.update(payload, false, fn, time());
        }

        dev.dispatch(addAction, {
          name: 'Initial State',
          payload: stripFunctions(state),
          time: (0).toFixed(2),
          store: storeName,
        })

        return a;
      }

      const container = document.createElement('div');
      document.body.appendChild(container)

      function DevApp() {
        this.style = `
          #radDevTools {
            display: block;
            width: 300px;
            position: fixed;
            right: 0;
            top: 0;
            height: 100%;
            z-index: 1000;
            background-color: #1f2323;
            color: #f0f0f0;
            padding: 10px;
          }
          #radDevTools > ul {
            display: block;
            width: 100%;
            margin: 0;
            padding: 0;
            list-style: none;
            cursor: default;
          }
          #radDevTools > ul > li.action {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #2d292d;
            border-bottom: 2px solid #1e2323;
            position: relative;
          }
          #radDevTools > ul > li.action:hover {
            background-color: #3d3240;
          }
          #radDevTools > ul > li.action.active {
            background-color: #725084;
          }
          #radDevTools > ul > li.action > i {
            position: absolute;
            right: 10px;
            font-size: 12px;
            opacity: 0.5;
          }
          #radDevTools > ul > li.action > strong {
            display: block;
            font-size: 14px;
            font-weight: normal;
            color: #98839e;
            margin-bottom: 4px;
          }
          #radDevTools > ul > li.action > strong strong {
            color: #fff;
          }
          #radDevTools > ul > li.action > span {
            color: #d9acff;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: monospace;
            display: block;
            width: 100%;
          }
        `
        return (
          <div id="radDevTools">
            <div>
              <pre>{dev.render(({active}) => (
                storeHolder[active]
              ))}</pre>
            </div>
            hello, I am dev tools
            <ul>
              {dev.render(({stores}) => stores.map(store => (
                <li class="store">{store}</li>
              )))}
              <hr/>
              <button onclick={e => dev.dispatch(previous)}>Previous</button>
              <button onclick={e => dev.dispatch(next)}>Next</button>
              <hr/>
              {dev.render(({actions, active}) => actions.map(action => (
                <li onclick={e => dev.dispatch(setActive, action.index)} class={['action', active === action.index && 'active'].filter(a => a).join(' ')}>
                  <i>+ {action.time}s</i>
                  <strong><strong>{action.name}</strong> @ {action.store}</strong>
                  <span>{JSON.stringify(action.payload)}</span>
                </li>
              )))}
            </ul>
          </div>
        )
      }

      _radi.mount(
        <DevApp/>,
        container
      )



      return {
        ..._radi,
        Store,
      }
    }


    const { h, mount, Store } = devTools(RadiExperiment);






    function Fetch(url, map) {
      // const load = (next) => (setTimeout(() => next(map({user:{_key: 123}})), 5000))
      return (payload) => {
        return (update) => setTimeout(update, 1000, map({user: {_key: 123} }))
        // return (update) => load((data) => state.dispatch(function Fetch() {return {[name]: data} }))
        // return (state, name) => load((data) => state.dispatch(function Fetch() {return {[name]: data} }))
      }
    }

    const Interests = new Fetch(
      '/user/:id',
      ({user}) => ({
        id: user._key,
      })
    );

    const User = new Fetch(
      '/user/:id',
      ({user}) => ({
        id: user._key,
        firstname: user.firstname,
        lastname: user.lastname,
        hobbies: user.interests,
        interests: Interests({id: 1}),
      })
    );

    const userState = new Store({
      id: 12,
      user: User({id: 10}),
      // user: null,
    }, 'userState')

    // const getUser = (state, id) => ({user: User({id})}) // => Update user in next async action
    //
    // setTimeout(() => {
    //   userState.dispatch(getUser, 12)
    //   userState.dispatchIn('user', getUser, 12)
    // }, 1000)







    // const store = new Store({
    //   rows: [],
    // }, 'Store')
    //
    // const create = (state, count) => {
    //   return {
    //     rows: buildData(count, 0),
    //   }
    // }
    //
    // const remove = ({rows}, count) => {
    //   return {
    //     rows: count ? rows.slice(0,count) : [],
    //   }
    // }
    //
    // const every = ({rows}, interval) => {
    //   return {
    //     rows: rows.map((r, i) => (
    //       !((i + 1) % interval)
    //         ? { ...r, value: r.value + ' !!!' }
    //         : r
    //     )),
    //   }
    // }
    //
    // const swap = ({rows}, from, to) => {
    //   const temp1 = {...(rows.slice(from, from+1)[0])}
    //   const temp2 = {...(rows.slice(to, to+1)[0])}
    //   rows[from] = temp2;
    //   rows[to] = temp1;
    //   return {
    //     rows,
    //   }
    // }
    //
    // const reverse = ({rows}) => {
    //   return {
    //     rows: rows.reverse(),
    //   }
    // }
    //
    // const App = function() {
    //   return (
    //     <div>
    //       <h1 style={{color: 'red'}}>Hello World</h1>
    //       <button onclick={ e => store.dispatch(create, 1) }>Create 1</button>
    //       <button onclick={ e => store.dispatch(create, 1000) }>Create 1k</button>
    //       <button onclick={ e => store.dispatch(create, 10000) }>Create 10k</button>
    //       <button onclick={ e => store.dispatch(reverse) }>reverse</button>
    //       <button onclick={ e => store.dispatch(every, 10) }>every 10</button>
    //       <button onclick={ e => store.dispatch(swap, 4, 9) }>swap 4,9</button>
    //       <button onclick={ e => store.dispatch(remove) }>remove</button>
    //       <ul>
    //         {store.render(v => v.rows.map((item,n) => <li>{item.id}. {item.value}</li>))}
    //       </ul>
    //     </div>
    //   )
    // }
    //
    //
    //
    //
    //
    // const sinwave = new Store({
    //   barWidth: 1,
    //   barCount: 100,
    //   active: false,
    //   count: 0,
    //   step: 0.5,
    //   translateY: 0,
    //   rotation: 0,
    //   bars: [],
    // }, 'Sinwave')
    //
    // const getColors = ({barCount, count}) => {
    //   let arr = [];
    //   for (var i = 0; i < barCount; i++) {
    //     var hue = (360 / barCount * i - count) % 360;
    //     var t = Math.sin(count/10 + i/5) * 100 * .5;
    //     var r = (count+i)%360;
    //     arr.push({
    //       id: i,
    //       color: 'hsl(' + hue + ',95%,55%)',
    //       translateY: t,
    //       rotation: r,
    //     });
    //   }
    //   return arr;
    // }
    //
    // const sinwaveTick = (state) => {
    //   if (state.active) {
    //     window.requestAnimationFrame(() => {
    //       sinwave.dispatch(sinwaveTick);
    //     });
    //     return {
    //       bars: getColors(state),
    //       count: state.count + state.step,
    //     }
    //   }
    //   return {}
    // }
    //
    // const start = () => ({
    //   active: true,
    // })
    //
    // const stop = () => ({
    //   active: false,
    // })
    //
    // function Sinwave() {
    //   return (
    //     <div>
    //       <div class="animated-sin-wave">
    //         {sinwave.render((state) => (
    //           state.bars.map((bar, i) => <div class="bar" style={{
    //             width: state.barWidth + '%',
    //             left: ( state.barWidth * i ) + '%',
    //             transform: 'scale(0.8,.5) translateY(' + bar.translateY + '%) rotate(' + bar.rotation + 'deg)',
    //             backgroundColor: bar.color,
    //           }}></div>)
    //         ))}
    //       </div>
    //       <button onclick={e => (
    //         sinwave.dispatch(start),
    //         sinwave.dispatch(sinwaveTick)
    //       )}>Start</button>
    //     </div>
    //   )
    // }

    /* Firstly we define state */
    const counter = new Store({
      count: 0,
      user: userState.inject,
    }, 'Counter')

    /* Then we define some actions that will change state */
    const up = ({count}, by) => ({count: count + by})
    const down = ({count}, by) => ({count: count - by})

    /* Then comes pure function component */
    function Counter() {
      return (
        <div>
          <pre>{ counter.render(({user}) => JSON.stringify(user)) }</pre>
          <h1>{ counter.render(s => s.count) }</h1>
          <button onclick={ () => counter.dispatch(up, 1) }>Up</button>
          <button onclick={ () => counter.dispatch(down, 1) }>Down</button>
        </div>
      )
    }

    mount(
      // Counter,
      // <Sinwave/>,
      <div>
        <Counter/>
      </div>,
      // <h1><Counter/></h1>,
      // <h2>Hello World</h2>,
      // [1,2,3],
      // [1, clock.render(v => [2, v.time, 3]), 4],
      app
    );



    // function ensureArray(a) {
    //   if (arguments.length === 0) return [];            // no args, ret []
    //   if (arguments.length === 1) {                     // single argument
    //     if (a === undefined || a === null) return [];   // undefined or null, ret []
    //     if (Array.isArray(a)) return a;                 // isArray, return it
    //   }
    //   return Array.prototype.slice.call(arguments);     // return array with copy of all arguments
    // }
    //
    //
    // function text(string) {
    //   return document.createTextNode(string);
    // }
    //
    // function updateElement(newNode, oldNode, $pointer) {
    //
    // }
    //
    // function changed(node1, node2) {
    //   return typeof node1 !== typeof node2 ||
    //     (
    //       (typeof node1 === 'string' || typeof node1 === 'number')
    //       && node1 !== node2) ||
    //     node1.type !== node2.type ||
    //     node1.props && node1.props.forceUpdate;
    // }
    //
    // function patch(newNode, oldNode, $parent, index = 0, $pointer) {
    //   if ($pointer) {
    //     index = Array.prototype.indexOf.call($parent.childNodes, $pointer) + 1;
    //   }
    //   const normalNewNode = ensureArray(newNode || []);
    //   const normalOldNode = ensureArray(oldNode || []);
    //   const newLength = normalNewNode.length;
    //   const oldLength = normalOldNode.length;
    //
    //   for (let i = 0; i < newLength || i < oldLength; i++) {
    //     if (!normalOldNode[i]) {
    //       $parent.appendChild(
    //         text(normalNewNode[i])
    //       )
    //     } else
    //     if (!normalNewNode[i]) {
    //       $parent.removeChild(
    //         $parent.childNodes[index]
    //       )
    //     } else if (changed(newNode, oldNode)) {
    //       $parent.replaceChild(
    //         text(normalNewNode[i]),
    //         $parent.childNodes[index + i]
    //       );
    //     }
    //     // updateElement(normalNewNode[i], normalOldNode[i], $pointer);
    //     console.log(i, {new: normalNewNode[i], old: normalOldNode[i], $pointer})
    //   }
    //
    //   console.log({normalNewNode, normalOldNode})
    // }
    //
    // const pointer = bbb.appendChild(text('[pointer]'))
    //
    // patch([1,2,3], [], bbb, 0, pointer)
    // patch(null, [1,2,3], bbb, 0, pointer)

  </script>
</body>
</html>
